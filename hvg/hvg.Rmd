---
title: "Find Highly Variable Genes"
output:
  html_document:
    df_print: paged
    toc: yes
    number_sections: true
    toc_float: true
    self_contained: true
    mathjax: default
    code_download: true
---







# Load data
On the CITEseq data, we play around with HVGs (highly variable genes), i.e.
superpoissonian genes.

```{r loadCITE}
file <- "~/sds/sd17l002/p/scRNAseq_datasets/CITEseq_NatMethods_2017/data/GSE100866_CBMC_8K_13AB_10X-RNA_umi.csv.gz"
rawC <- as.matrix(read.csv(gzfile(file), row.names = 1))

is_mouse <- colSums(rawC[grepl("MOUSE", rownames(rawC)),]) / colSums(rawC) > .1
rawC <- rawC[grepl("HUMAN", rownames(rawC)), ! is_mouse]

```



# ColSums, Gene Means and Poisson raw counts

```{r}
cs <- colSums(rawC)

# estimate each gene's true mean by normalizing with library size first:
normC <- t( t(rawC) / cs)
allM <- apply(normC, 1, mean)
allV <- apply(normC, 1, var)


# simulate poisson raw counts for our data:
pCounts <- t(sapply(allM, function(mu) rpois(ncol(rawC), lambda = mu * cs)))
rownames(pCounts) <- paste0("poisson_", 1:nrow(pCounts))
colnames(pCounts) <- paste0("Cell_", 1:ncol(pCounts))

pCounts_small <- Matrix(
  pCounts[sample(1:nrow(pCounts), 8000), sample(1:ncol(pCounts), 1000)], sparse=T)
rawC_small <- Matrix(
  rawC[sample(1:nrow(rawC), 8000), sample(1:ncol(rawC), 1000)], sparse=T)
```

















# Seurat's means and disps

FindVariableGenes by default uses ExpMean and LogVMR, which effectively do this
with the lognormalized values x:

```{r}
x  <- s@data["poisson_1305", ]
expMean <-  log(
              x = mean(x = exp(x = x) - 1) + 1 )

disp    <-  log(
              x = var(x = exp(x = x) - 1) / mean(x = exp(x = x) - 1) )



xf <- pCounts["poisson_1305", ]  / cs 

```

I find this worrying.


# Seurat on poisson genes

```{r}
library(Seurat)

s <- CreateSeuratObject(pCounts)
s <- NormalizeData(s)
s <- FindVariableGenes(s, display.progress = F)
length(s@var.genes)
```
Seurat finds 600 HVGs where there is no biological information at all.
```{r}
s <- ScaleData(object = s, vars.to.regress = c("nUMI"))
s <- RunPCA(s, pc.genes = s@var.genes, do.print = F)
s <- JackStraw(object = s, num.replicate = 100, display.progress = FALSE)
JackStrawPlot(object =s, PCs = 1:12)
```
```{r}
s <- FindClusters(object = s, reduction.type = "pca", dims.use = 1:7, 
    resolution = 0.6, print.output = 0, save.SNN = TRUE)
s <- RunTSNE(object = s, dims.use = 1:7, do.fast = TRUE)
TSNEPlot(s)
```

# Monocle on Poisson genes

```{r}
library(monocle)
pd <- new("AnnotatedDataFrame", data = data.frame(
  cellID = colnames(pCounts_small),
  row.names = colnames(pCounts_small)))
fd <- new("AnnotatedDataFrame",
          data.frame(gene_short_name= rownames(pCounts_small),
                 row.names=rownames(pCounts_small)))
cds_p <- newCellDataSet(Matrix(pCounts_small, sparse = T), phenoData = pd, featureData = fd,
                      expressionFamily = negbinomial.size())

pd <- new("AnnotatedDataFrame", data = data.frame(
  cellID = colnames(rawC_small),
  row.names = colnames(rawC_small)))
fd <- new("AnnotatedDataFrame",
          data.frame(gene_short_name= rownames(rawC_small), 
                 row.names=rownames(rawC_small)))
cds  <- newCellDataSet(Matrix(rawC_small, sparse = T), phenoData = pd, featureData = fd,
                      expressionFamily = negbinomial.size())




cds <- estimateSizeFactors(cds); cds <- estimateDispersions(cds)
cds_p <- estimateSizeFactors(cds_p); cds_p <- estimateDispersions(cds_p)
disp_table <- dispersionTable(cds)
disp_table_p <- dispersionTable(cds_p)


plot(disp_table$mean_expression, disp_table$dispersion_empirical, log="xy",
     pch=20, cex=.3, xlab = "Mean Expression", ylab="Empirical dispersion",
     col = "#00000090", # transparent black
     main="Monocle's dispersion estimates\nRed: simulated poisson genes")
points(disp_table_p$mean_expression, disp_table_p$dispersion_empirical, pch = 20, cex=.3, col="#ff000090")
```

We see that monocle could gain a lot by simply modelling poisson noise and
plotting it into their dispersion plot.

# [code chunks]

```{r}
normP <- t( t(poiss) / colSums(rawC))
allMP <- apply(normP, 1, mean)
allVP <- apply(normP, 1, var)
plot(allM, allV/allM, log = "xy", pch = 20, cex=.1, col = "#00000040")
points(allMP, allVP / allMP, col = "red", pch = 20, cex=.1)
```

# Local quantile fit

To select HVGs, we want to know where the Poisson-regime ends. For this, we'll
fit lines through the mean/median and the 90%-quantile using local quantile regression:
```{r}
# Simon wants to filter out low-abundance genes. A very conservative cutoff is
# the mean resulting from 1 small cell (nUMI = 500) having an UMI of 1, the rest 0.
threshold <- mean(c(1/500,  rep(0, ncol(rawC)-1)))

# ease of typing (Poisson stats):
is_na <-  is.na(allVP/allMP) | is.na(allMP)
 mu <- allMP[!is_na & allMP > threshold]
vmr <- allVP[!is_na & allMP > threshold] / allMP[!is_na & allMP > threshold]

x <- log(mu)
y <- log(vmr)


 # going over all x takes too long:
xrange <- log(c(max(1e-9, min(allM), min(allMP)), max(max(allM), max(allMP))))
bin_n <- 75
bin_x <- seq(xrange[1], xrange[2], length.out = bin_n)


library(quantreg)
mm <- cbind( 1, x, x^2 )
yfit <-
 sapply( bin_x, function(xp) {
   fit <- rq.wfit( mm, y, .9, dnorm( x, mean=xp, sd=2 ) )
   fit_median <- rq.wfit( mm, y, .5, dnorm( x, mean=xp, sd=2 ) )
   c(   q90 = fit$coefficients %*% c( 1, xp, xp^2 ),
     median = fit_median$coefficients %*% c( 1, xp, xp^2 ))
   })


plot(log(allM), log(allV/allM), pch=20, cex=.1)
points(x, y, pch=20, cex=.1, col ="red")
lines( bin_x, yfit[1,], lwd = 2, col="orange" )
lines( bin_x, yfit[2,], lwd = 2, col="magenta" )
lines( bin_x, yfit["median", ] + 10*(yfit["q90", ] - yfit["median",]), lwd = 2, lty = "dashed", col="green" )

```
The green line is at the moment a bit arbitrarily chosen as the median plus
10 times the difference from median to 90 quantile. We'll decide later what works
best.










# End of Script

```{r}
devtools::session_info()
```


