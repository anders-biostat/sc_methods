---
title: "Find Highly Variable Genes"
output:
  html_document:
    df_print: paged
    toc: yes
    number_sections: true
    toc_float: true
    self_contained: true
    mathjax: default
    code_download: true
---




# Load Packages

```{r}
library(ggplot2)
library(pbmcapply) # parallelization
library(quantreg)  # quantile regression with rq.wfit
library(parallelDist)
```



# Load data
On the CITEseq data, we play around with HVGs (highly variable genes), i.e.
superpoissonian genes.

```{r loadCITE}
citeDIR <- "~/sds/sd17l002/p/scRNAseq_datasets/CITEseq_NatMethods_2017/data/"
rna_file <- paste0(citeDIR, "GSE100866_CBMC_8K_13AB_10X-RNA_umi.csv.gz")
adt_file <- paste0(citeDIR, "GSE100866_CBMC_8K_13AB_10X-ADT_umi.csv.gz")

rawC <- as.matrix(read.csv(gzfile(rna_file), row.names = 1))
prot <- as.matrix(read.csv(gzfile(adt_file), row.names = 1))

# exclude mouse cells:
is_mouse <- colSums(rawC[grepl("MOUSE", rownames(rawC)),]) / colSums(rawC) > .1
rawC <- rawC[grepl("HUMAN", rownames(rawC)), ! is_mouse]
prot <- prot[, ! is_mouse]
```




# RNA data: normalization

```{r}
normC <- apply( rawC, 2, function(col) {
  (sqrt(col+3/8)-sqrt(3/8)) / sqrt(sum(col))
})

```




# Protein data: normalization and Cell identities
```{r}
# simplifying Seurat's code to compute Centered Log Ratio (CLR):
norm_prot <- apply(prot, 1, function(x) {
  log1p( (x) /
                          (exp(sum(log1p((x)[x > 0]), na.rm = TRUE)/length(x + 1))) ) })


 # exclude NK and monos:
  plot(norm_prot[, "CD11c"], norm_prot[, "CD56"], pch =20, cex=.1, 
       main = "CITEseqs protein data\nto exclude NKs (CD56) and myeloid cells (CD11c)")
  lin_neg <- norm_prot[, "CD56"] < 1.1   & norm_prot[, "CD11c"] < 1 
 
# exclude erythrocytes. No good protein marker available, we use RNA for it:
  not_ery <- normC["HUMAN_HBB", ]  < .05  &
             normC["HUMAN_HBG2", ] < .05 &
             normC["HUMAN_HBA1", ] < .04 
# same for platelets / megakaryocytes:
  not_platelet <- normC["HUMAN_GP9", ] < .005 &
                  normC["HUMAN_PF4", ] < .005 &
                  normC["HUMAN_PPBP", ] < .005 
  
  
# B and T cells:
  has_B_markers <- norm_prot[, "CD19"] > 2  &  norm_prot[, "CD3"] < .5
  has_T_markers <- norm_prot[, "CD19"] < 1.5  &  norm_prot[, "CD3"] > 1
  plot(norm_prot[, "CD3"], norm_prot[, "CD19"], pch =20, col =
         rgb(has_B_markers, has_T_markers, .7 *lin_neg),
       main = "B and T cells in red and green\nCD56-CD11c- in blue\nPick cells with mixture colors")

  
    
  isBcell <- has_B_markers & lin_neg & not_ery & not_platelet
  isTcell <- has_T_markers & lin_neg & not_ery & not_platelet

  
  
  has_CD4 <- norm_prot[, "CD4"] > 1  &  norm_prot[, "CD8"] < 1
  has_CD8 <- norm_prot[, "CD4"] < .5  &  norm_prot[, "CD8"] > 3
  isCD4Tcell <- isTcell & has_CD4
  isCD8Tcell <- isTcell & has_CD8
   
  plot(norm_prot[, "CD4"], norm_prot[, "CD8"], pch=20, cex=.4,
       col = rgb(0, isCD4Tcell, isCD8Tcell), 
       main = "CD4 and CD8 T cells\nselected amongst T cells picked above")  
  
  
Ts <- isCD4Tcell | isCD8Tcell
```




# VMRstats function
```{r}
## bug report for below function(s):
  #
  #  This function is terrible coding practice; rewrite it completely!
  #
  #  rowMeans(rawC) and allM is redundant computation, that's uncritical but not elegant
  #
  #  everytime you run it, different genes get selected due to stochastic poisson.
  #  We'll probably find an analytic solution eventually anyways that should fix it.

                                                  ##

VMRstats <- function(mat = rawC, nbin_qreg = 75) {
  cs <- colSums(mat) 
  
  # Simon wants to filter out low-abundance genes. A very conservative cutoff is
  # the mean resulting from 1 small cell (nUMI = 500) having an UMI of 1, the rest 0s:
  threshold <- mean(c(1/500,  rep(0, ncol(mat)-1)))
    print("Simulate Poisson Counts...")
  # estimate each gene's true mean and var - for this we normalize with library size:
    normC <- t( t(mat) / cs)
    normC <- normC[rowMeans(normC) > threshold,]
    allM <- apply(normC, 1, mean)
    allV <- apply(normC, 1, var)
  
  
  # simulate poisson raw counts relevant to our data (i.e. using allM):
    nc <- ncol(mat)
    pCounts <- do.call(rbind,
                       pbmclapply(allM, function(mu) {rpois(nc, lambda = mu * cs)},
                                  mc.cores=4) )
    # superfluous, here because I used to punch these into Seurat:
    rownames(pCounts) <- paste0("poisson_", 1:nrow(pCounts))
    colnames(pCounts) <- paste0("Cell_", 1:ncol(pCounts))
  
    print("Normalize Poisson Counts...")
  # as with real counts:
    normP <- t( t(pCounts) / cs)
    allMP <- apply(normP, 1, mean)
    allVP <- apply(normP, 1, var)
    # x,y for ease of typing. threshold also prevents -Inf values, defensive progr.:
    x <- log(allMP[allMP > threshold])
    y <- log(allVP[allMP > threshold] / allMP[allMP > threshold])
  
  print("Fit VMR-mean relationship...")
  # going over all x takes long, so we fit the VMR-mean relationship in bins:
  xrange <- range(x) # log(c(max(1e-9, min(allM), min(allMP)), max(max(allM), max(allMP))))
  bin_x <- seq(xrange[1], xrange[2], length.out = nbin_qreg)
  # random poisson by chance might not cover the extreme values:
  bin_x <- c(log(min(allM)), bin_x, log(max(allM)))
  
  # Simon's local quantile fit (faster using matrix notation, `mm`)
  mm <- cbind( Intercept = 1, X = x, X2 = x^2 )
  yfit <- do.call(rbind, pbmclapply( bin_x, function(xp)
    {
        fit        <- rq.wfit( mm, y, .75, dnorm( x, mean=xp, sd=2 ) )
        fit_median <- rq.wfit( mm, y, .5, dnorm( x, mean=xp, sd=2 ) )
        c(bin_x = xp,
          q75= fit$coefficients %*% c( 1, xp, xp^2 ),
          median = fit_median$coefficients %*% c( 1, xp, xp^2 ))
    } )  )
  
  # interpolate Poisson median and quantile for each gene: 
  all_y<- do.call(data.frame,
                 c( 
                   poisson_medians <- approx(x = yfit[, "bin_x"],
                                             y = yfit[, "median"],
                                             xout = log(allM)),
                   poisson_q75     <- approx(x = yfit[, "bin_x"],
                                             y = yfit[, "q75"],
                                             xout = log(allM)) ) )
  # return final result:
  data.frame(
      log_Gene_Mean         = all_y[, 1],
      log_Gene_VMR          = log(allV / allM),
      log_PoissonVMR_median = all_y[, 2],
      log_PoissonVMR_q75    = all_y[, 4],
      IQR_of_logged_VMR         = 2 * (all_y[, 4] - all_y[, 2]),
      row.names = rownames(all_y)
    )
  } 


getHVG <- function(vmrstats = VMRstats(rawCounts), IQRs = 10) {
  # returns genes that are more than n IQRs away (default: n = 10).
  hvg  <- vmrstats$log_Gene_VMR >
         vmrstats$log_PoissonVMR_median + IQRs * vmrstats$IQR_of_logged_VMR
  return(vmrstats[hvg, ])
}
```



# test getHVG function

```{r}
v <- VMRstats(rawC[, Ts])
v <- v[order(v$log_Gene_Mean), ]


hvg10 <- v$log_Gene_VMR >
         v$log_PoissonVMR_median + 10 * v$IQR_of_logged_VMR


plot(v$log_Gene_Mean, v$log_Gene_VMR, pch = 20, cex=.1, col = "#00000090")
lines(v$log_Gene_Mean, v$log_PoissonVMR_median,
      lwd = 1.5, col = "orange")
lines(v$log_Gene_Mean, v$log_PoissonVMR_q75,
      lwd = 1.5, lty = "dashed", col = "orange")
lines(v$log_Gene_Mean,
      v$log_PoissonVMR_median + v$IQR_of_logged_VMR,
      lwd = 1.5, lty="dashed", col = "red")
points(v$log_Gene_Mean[hvg10], 
       v$log_Gene_VMR[hvg10], pch=20, col = "red")


```











# Savepoint

```{r}
# save.image(file = "/home/felix/PhDother/scAnalysis/sc_methods/hvg/savepoint/1.rda")
library(ggplot2)
library(pbmcapply) # parallelization
library(quantreg)  # quantile regression with rq.wfit
library(parallelDist)
load(file = "/home/felix/PhDother/scAnalysis/sc_methods/hvg/savepoint/1.rda")
```




# Sveta's variance of Poisson-variance

I simulate poisson counts:
```{r}
cs <- colSums(rawC[, Ts]) 
# estimate each gene's true mean and var - for this we normalize with library size:
estMeans <- apply(t( t(rawC[ rowMeans(rawC[, Ts]) > 0.00530, Ts]) / cs), 1, mean)
estMeans <- sample(estMeans, 1000)

# simulate poisson raw counts relevant to our data (i.e. using allM):
    nc <- ncol(rawC[, Ts])
   
    
    poisson_replicates <- replicate(100, { 
    singlePoisson <- do.call(rbind,
                           lapply(estMeans, function(mu) rpois(nc, lambda = mu * cs))
                           )
    
    apply( t(singlePoisson) / cs, 2, var)} )
    
    
    
# Sveta's variance estimation:
    var_theo <- function(mu, colsums = colSums(rawC[, Ts])) {
     N   <- length(colsums)
     psi <- sum(1/colsums) / N
     
     vt <- 2/(N-1)/(N-1) * mu^2 * psi^2 +
           (2*N-4)/(N*(N-1)^2) * mu * mu * sum(1/(colsums^2)) +
           mu / N / N * sum(1/(colsums^3))
    }


plot(apply(poisson_replicates, 1, var), var_theo(estMeans, cs), log = "xy")

all.equal(apply(poisson_replicates, 1, var), var_theo(estMeans, cs))


```

```{r}
poisson_sds <- sqrt( var_theo(exp(v$log_Gene_Mean), colSums(rawC[, Ts])) )

plot(v$log_Gene_Mean, v$log_Gene_VMR, pch = 20, cex=.1, col = "#00000090")
lines(v$log_Gene_Mean, v$log_PoissonVMR_median,
      lwd = 1.5, col = "orange")
lines(v$log_Gene_Mean, )
```











# Plausible gene means informed by the CITEseq dataset 
This is useful for all kinds of simulations.
```{r}
plausible_means <- c( 
  runif(575, min = .5, max = 1),
  runif(267, min = 1,  max = 2),
  runif(190, min = 2,  max = 10),
  runif(70, min = 10, max = 40)  )
# compare to citeseq by loading rawC as in hvg.Rmd, followed by:
# cs <- colSums(rawC)
# normC <- t( t(rawC) *mean(cs)/ cs)
# table(round(rowMeans(normC)))
# rms <- rowMeans(normC)
# plot(table(round(plausible_means, digits = 1 )), main = "Simulated means", ylab = "Number of Genes")
# plot(table(round(rms[rms < 40 & rms > .5], digits = 1)), main = "CITEseq means (> .5 UMIs)", ylab="Number of Genes")
```



## Power analysis
```{r}
n1 = 2500 # number of cells in population 1
n2 = 250 # number of cells in population 2
nP = n1+n2   # sum of all cells (nP = n for poisson simulation)
foldchange = 2

fc <- as.data.frame(do.call(rbind,
lapply(plausible_means, function(m) {
  x <- c(rpois(n1, m), rpois(n2, foldchange * m))
  c(mean = mean(x), var = var(x), vmr = var(x) / mean(x))
})
) )

P <- as.data.frame(do.call(rbind,
lapply(plausible_means, function(m) {
  x <- rpois(nP, m)
  c(mean = mean(x), var = var(x), vmr = var(x) / mean(x))
})
) )

plot(fc$mean, fc$vmr, log = "xy", pch = 20, cex=.1,
     ylim = range(c(fc$vmr, P$vmr)),
     xlim = range(c(fc$mean, P$mean)))
points(P$mean,   P$vmr, pch=20, cex=.1, col = "red")

```









# Play zone





## Covariance of Poisson estimators
```{r}
# My VMR-over-mean plot implicitly estimates the true variance and mean of each
# gene, and the vmr as well. Sveta has come up with formulas for the variances
# of the first two estimators (mean_hat and var_hat), and from these I can compute
# the variance of the vmr estimator. This follows the formula
#
#      var(log_vmr) = var(log_var) + var(-log_mean) + 2 * cov(log_var, -log_mean)
#
# It is interesting for me to see whether the covariance of log_var and log_mean
# is 0 as hoped, or if it's above.

meanvar_correl <- do.call(rbind, lapply(exp(-5:10), function(x) {

cors <- t(replicate(5, {
  mv <- t(replicate(100, expr = {
  p <- rpois(8000, x)
  c(mean(p), var(p)) } ))
  c( lambda = x, varmean_cov = cov(log(mv[,1]), log(mv[,2]) ), var_of_var = var(log(mv[, 2])),
     var_of_mean = var(log(mv[, 1])))
}))

}) )

plot(meanvar_correl, log = "x")
```


















```{r}
s <- MakeSparse(CreateSeuratObject(rawC[, Ts]))
s <- NormalizeData(s)
s <- FindVariableGenes(s, display.progress = F)
s@var.genes <- names(hvgs_T$hvg_2IQR)
s <- ScaleData(object = s, vars.to.regress = c("nUMI"),
               genes.use = s@var.genes,
               model.use = "negbinom", do.par = T, num.cores = 4, display.progress = T)
s <- RunPCA(s, pc.genes = s@var.genes, do.print = F)

d_seurat <- parallelDist::parDist(s@dr$pca@cell.embeddings[, 1:10],
                                  threads = 4)

ggplot(distanceDF_Tcells(d_seurat),
       aes(x = Distance, stat(density), fill = Group)) +
       geom_histogram(position = "identity", alpha = .6, binwidth = 1)
```






# weighted distance

```{r}

mat <- rawC[, Ts]
cs  <- colSums(mat)
mat <- mat[rownames(mat) %in% names(hvgs_T$hvg_2IQR) ,]

w <- apply(mat, 1, function(k) 1 / mean(1/ (k+.5)))

plot(w, col =
(1 + rownames(mat) %in% names(hvgs_T$hvg_2IQR) ))

d <- parDist(t(sqrt(w) * log( t(t(mat + .5) / cs)) ),
               threads = 4 )

ggplot(distanceDF_Tcells(d),
       aes(x = Distance, stat(density), fill = Group)) +
       geom_histogram(position = "identity", alpha = .6, binwidth = 1)

```








# Seurat's means and disps

FindVariableGenes by default uses ExpMean and LogVMR, which effectively do this
with the lognormalized values x:

```{r}
x  <- s@data["poisson_1305", ]
expMean <-  log(
              x = mean(x = exp(x = x) - 1) + 1 )

disp    <-  log(
              x = var(x = exp(x = x) - 1) / mean(x = exp(x = x) - 1) )



xf <- pCounts["poisson_1305", ]  / cs 

```

I find this worrying.



# End of Script

```{r}
devtools::session_info()
```


