---
title: "Find Highly Variable Genes"
output:
  html_document:
    df_print: paged
    toc: yes
    number_sections: true
    toc_float: true
    self_contained: true
    mathjax: default
    code_download: true
---



# Load data
On the CITEseq data, we play around with HVGs (highly variable genes), i.e.
superpoissonian genes.

```{r loadCITE}
file <- "~/sds/sd17l002/p/scRNAseq_datasets/CITEseq_NatMethods_2017/data/GSE100866_CBMC_8K_13AB_10X-RNA_umi.csv.gz"
rawC <- as.matrix(read.csv(gzfile(file), row.names = 1))

is_mouse <- colSums(rawC[grepl("MOUSE", rownames(rawC)),]) / colSums(rawC) > .1
rawC <- rawC[grepl("HUMAN", rownames(rawC)), ! is_mouse]

```

 
 
# VMR to find HVGs
Simon proved that the variance-over-mean ratio (VMR) is an excellent measurement
to find superpoissonian genes, and that it can be computed on counts
(counts = rawCounts / colSums).

The beauty is that Poissonian Variance is a horizontal line when we plot VMR over 
the mean (log-log axis), so selecting superpoissonian genes (HVGs) is very
straight forward.

Here, we create the plot and simulate Poisson noise, thus the HVGs become
immediately clear as genes clearly above Poisson variance:

```{r}
cs <- colSums(rawC)
# simulate poisson raw counts for our data:
poiss <- t(
  apply(rawC, 1, function(gene) {
    rpois(ncol(rawC), lambda = mean(gene / cs) * cs)
  })
)


normC <- t( t(rawC) / cs)
allM <- apply(normC, 1, mean)
allV <- apply(normC, 1, var)

normP <- t( t(poiss) / colSums(rawC))
allMP <- apply(normP, 1, mean)
allVP <- apply(normP, 1, var)


plot(allM, allV/allM, log = "xy", pch = 20, cex=.1, col = "#00000040")
points(allMP, allVP / allMP, col = "red", pch = 20, cex=.1)
```

The straight line on the very left roughly follows this equation when 
$n_{cells\_nonzero}$ is 1 (found this by
trial and error):

$ var = \frac{n_{cells\_total}}{n_{cells\_nonzero}} \  \mu^2 $

and marks genes where exactly 1 cell has exactly 1 UMI count.
The position along the line depends on the cell's library size by which we normalize.
Somewhat less visible, there are parallel lines further to the right, and these
mark genes where 2 cells have 1 UMI - they are 'noisy' lines because the two
cells of course have different sizefactors.
Quick illustration:
```{r}
sapply(1:4, function(ones) {
  # exceptional counts:
  ec <- c(rep(1, ones), rep(0, ncol(poiss)-1))
  # no matter by which colsum we normalize, the ratio ov 
  sapply(c(150, 2000, 10000), function(sizefactor) {
      var(ec/sizefactor) / mean(ec/sizefactor) / mean(ec/sizefactor)
 })
})


tmp <- do.call(rbind, lapply(sapply(c(1:3,30), function(ones) {
    # exceptional counts:
    c(rep(1, ones), rep(0, ncol(poiss)-1)) }), function(counts) log(c(x=mean(counts/2000), y=var(counts/2000)/mean(counts/2000)))))
plot(x,y, pch=".", main="Red dots from left to right:\nGenes detected with 1 UMI in 1, 2, 3 and 30 cells\n position amongst each 'line' depends on cell's sizefactor.")
points(tmp[,1], tmp[,2], pch=20, col="red")
```




To select HVGs, we want to know where the Poisson-regime ends. For this, we'll
fit lines through the mean/median and the 90%-quantile using local quantile regression:
```{r}
# Simon wants to filter out genes. A very conservative cutoff is
# the mean resulting from 1 small cell (nUMI = 500) having an UMI of 1, the rest 0.
threshold <- mean(c(1/500,  rep(0, ncol(rawC)-1)))

# ease of typing (Poisson stats):
is_na <-  is.na(allVP/allMP) | is.na(allMP)
 mu <- allMP[!is_na & allMP > threshold]
vmr <- allVP[!is_na & allMP > threshold] / allMP[!is_na & allMP > threshold]

x <- log(mu)
y <- log(vmr)


 # going over all x takes too long:
xrange <- log(c(max(1e-9, min(allM), min(allMP)), max(max(allM), max(allMP))))
bin_n <- 75
bin_x <- seq(xrange[1], xrange[2], length.out = bin_n)



mm <- cbind( 1, x, x^2 )
yfit <-
 sapply( bin_x, function(xp) {
   fit <- rq.wfit( mm, y, .9, dnorm( x, mean=xp, sd=2 ) )
   fit_median <- rq.wfit( mm, y, .5, dnorm( x, mean=xp, sd=2 ) )
   c(   q95 = fit$coefficients %*% c( 1, xp, xp^2 ),
     median = fit_median$coefficients %*% c( 1, xp, xp^2 ))
   })


plot(log(allM), log(allV / allM), pch=20, cex=.1)
points(x, y, pch=20, cex=.1, col ="red")
lines( bin_x, yfit[1,], lwd = 2, col="orange" )
lines( bin_x, yfit[2,], lwd = 2, col="magenta" )
lines( bin_x, yfit["median", ] + 2*(yfit["q95", ] - yfit["median",]), lwd = 2, lty = "dashed", col="green" )




```





## Play zone 
```{r}
xrange <- log(c(max(1e-9, min(allM), min(allMP)), max(max(allM), max(allMP))))
bin_n <- 75

bin_x <- exp(seq(xrange[1], xrange[2], length.out = bin_n))
bin_d <- bin_x[2] - bin_x[1]

foo <- t(sapply(bin_x, function(x) {
  in_window <- allMP > (x - bin_d) & allMP < (x + bin_d)
  return(c(mean = mean(allMP[in_window]), var = mean(allVP[in_window])))
}))

binstats <- data.frame()
for(i in 1:length(bin_x)) {
  lower <- ifelse(i == 1,
                  bin_x[i],
                  bin_x[i] - (bin_x[i] - bin_x[i-1])/2)
  upper <- ifelse(i == length(bin_x),
                  bin_x[i],
                  bin_x[i] + (bin_x[i+1] - bin_x[i])/2)
  in_window <- allMP > lower & allMP < upper
 binstats <- rbind(binstats, 
                   data.frame(mean = mean(allMP[in_window]),
                              var = mean(allVP[in_window]),
                              q95 = quantile(allVP[in_window], .95)))
}

plot(allM, allV/allM, log = "xy", pch = 20, cex=.1, col = "#11000040")
points(allMP, allVP/allMP, col = "blue", pch=20, cex=.1)
points(binstats$mean, binstats$q95 / binstats$mean, pch=20, col="blue")


library(quantreg)
fit_l <- rq(log(allVP/allMP) ~ log(allMP), tau = .95)
plot(log(allM), log(allV/allM), pch=20, cex=.1, col = "#00000040")
points(log(allMP), log(allVP / allMP), pch=20, cex=.1, col = "red")
abline(fit_l, col = "green")




fit <- rq(allVP/allMP ~ allMP, tau = .95)
fit_x <- bin_x
fit_y <- coef(fit)[1] + coef(fit)[2] * bin_x
plot(allM, allV/allM, log = "xy", pch = 20, cex=.1, col = "#11000040")
points(fit_x, fit_y, pch=20, col = "red")


```
 


# Other findings
 Finding (not shown): for erythrocytes, more than half of all counts are one
 or two genes, usually hemoglobin chains. Therefore, estimating SE of colSums for
 these cells with bootstrapping results in huge variation, depending on whether
 the bootstrap run picked one of these highest genes or not.
 
 
 
Finding: inflating poisson noise by deliberately mispicking size factors
a bit seems insignificant. We had thought this might cause the red poisson cloud
to swallow the black cloud completely so that only clear outliers remain outside,
but it didn't. See also [deprecated]-section below (if it's not deleted yet).
```{r}

cs <- colSums(rawC)
# this is a single bootstrap run to get the colSum estimate a bit imprecise,
# which simulates additional noise introduced by our normalization:
cs2 <- apply(rawC, 2, function(x) sum(sample(x, replace = T)))


poiss <- t(
  apply(rawC, 1, function(gene) {
  rpois(ncol(rawC), lambda = mean(gene / cs) * cs2)

  }))


normC <- t( t(rawC) / cs)
allM <- apply(normC, 1, mean)
allV <- apply(normC, 1, var)
plot(allM, allV/allM, log = "xy", pch = 20, cex=.1, col = "#00000040")

normP <- t( t(poiss) / colSums(rawC))
allMP <- apply(normP, 1, mean)
allVP <- apply(normP, 1, var)
points(allMP, allVP / allMP, col = "red", pch = 20, cex=.1)
```

Generative model:
```{r}
# homogeneous cells still vary in gene expression, probably gaussian but I'll
# do poisson for no reason:
gene_RNA <- rpois(8000, lambda = 300)
# possible efficiencies of reverse transcription:
rte <- seq(0.13, 0.17, length.out = length(gene))
gene_cDNA <- rbinom(length(gene_RNA), size = gene_RNA, prob = sample(rte, replace = T))
mean(gene_cDNA); var(gene_cDNA)
```
I note that variation is larger than predicted by a poisson from the mean.



```{r}
x <- rawC["HUMAN_CCL3", ]

fitNB(x, sf = colSums(rawC))
 mean(x/colSums(rawC)); var(x/colSums(rawC))
cs <- colSums(rawC)

# Notes on the next chunk:
# above 1 means superpoissonian. Without normalizing, the poisson variance
# would be the equal to lambda, this lambda depends on the cell's size factors
# obviously. 
# we use bootstrapping 
# to find genes that certainly lie above 1.
bs_1 <- apply(rawC, 1, function(x) {
  nx <- x / cs
  min(replicate(100, {
    nxbs <- sample(nx, replace = T)
    var(nxbs) / mean(nxbs) 
  })/ mean(1 / cs))
  
})

bs_2 <- apply(rawC, 1, function(x) {
  nx <- x / cs
  min(replicate(100, {
    nxbs <- sample(nx, replace = T)
    var(nxbs) / mean(nxbs) 
  })/ mean(1 / cs))
  
})

```







#[deprecated] Other size-factor methods

I have also tried GMPR and scran-pooling, and here are some code chunks from this.
The result, however, remained the same: some points with moderately high means
are located just above the poisson-only genes. We conclude from this and after some
discussion the following:
for most genes, biological variation is smaller than poisson noise so they're 
completely inside the 'poisson-only cloud' of genes; other genes are clearly
HVGs, and then a bunch of genes might have some biological variation but not 
enough to emancipate over the poisson noise. Initially we thought inprecise
size-factor estimation would contribute the additional observed noise, in which case
more precise size factors would be helpful. Above we've played around quite a bit
with this, though, and do not think so any more.


Below GMPR function is adopted from the following source:

  * Title: Geometric Mean of Pairwise Ratios (GMPR) for Microbiome Sequencing data normalization
  * Version: 0.1
  * Authors: Jun Chen (chen.jun2@mayo.edu)
  * Date: 2017/02/07
  * Description: The function calculates the normalizing factors for microbiome sequencing data or generally zeroinflated sequencing data. 
  * The size factors can be used as offsets in count-based regression models or as devisors to produce normalized data

Felix tweaked it so support parallelization.

```{r, eval = }

top5000 <- names(sort(rowMeans(rawC), decreasing =  TRUE)[1:5000])
topC <- rawC[top5000, ]


use_cells <- sample(1:ncol(rawC), ncol(rawC))

library(pbmcapply)


sfs <- pbmclapply(use_cells, function(cell1) {  
  if(cell1 %% 100 == 0) { print(cell1)}
exp(mean(log(sapply(1:ncol(topC), function(cell2) {
 nz <- topC[, cell1] != 0 & topC[, cell2] != 0
 median(topC[nz, cell1] / topC[nz, cell2])
 
}))))
})
# save(sfs, file = "~/savepoint/citeseq_gmpr_sizefactors.RData")
sfs <- as.numeric(sfs); names(sfs) <- colnames(rawC[, use_cells])



library(scran)
sce <- SingleCellExperiment(list(counts=rawC[, use_cells]))
clusters <- quickCluster(sce, min.size = 100)
sce <- computeSumFactors(sce, cluster = clusters)
 # sizeFactors(sce)
```






Geometric mean with pairwise ratios (GMPR):
```{r}
poiss <- poisGenes(rawC[, use_cells], sizefactors = sfs)

normC <- t( t(rawC[, use_cells]) / sfs)
allM <- apply(normC, 1, mean)
allV <- apply(normC, 1, var)
plot(allM, allV/allM, log = "xy", pch = 20, cex=.1, col = "#00000040",  ylim = c(3e-2, 1e3))
points(poiss[,1], poiss[,2]/poiss[,1], col = "red", pch = 20, cex=.1)
```

With scran pooling:
```{r}
poiss <- poisGenes(rawC[, use_cells], sizefactors = sizeFactors(sce))

normC <- t( t(rawC[, use_cells]) / sizeFactors(sce))
allM <- apply(normC, 1, mean)
allV <- apply(normC, 1, var)
plot(allM, allV/allM, log = "xy", pch = 20, cex=.1, col = "#00000040")
points(poiss[,1], poiss[,2]/poiss[,1], col = "red", pch = 20, cex=.1)
```


